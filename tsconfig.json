//이 파일이 있으면 visual studio code는 우리가 타입스크립트로 작업한다는 것을 즉시 알게되고, 자동완성 기능을 제공한다.

//어디에 타입스크립트 파일이 위치하는지 알려준다.
//include의 배열에는 우리가 자바스크립트로 컴파일하고 싶은 모든 디렉터리를 넣어준다.
//src를 적어준다는 것은 타입스크립트가 src의 모든 파일을 확인한다는 것을 의미한다.

//outDir는 자바스크립트 파일이 생성될 디렉터리를 지정한다.
//타입스크립트는 컴파일러이기 때문에 이 파일들을 일반적인 자바스크립트로 컴파일 시켜줄 것이다.
//우리는 build라는 폴더에 만들어진 코드를 넣을 것이기 때문에 outDir에 build라고 써준다.
//이것을 설정해준 대로 잘 작동하는지 보기 위해서 package.json의 "script"에 "build"라는 새 스크립트를 추가해준다.
//그 후에 npm run build하면 build 폴더가 생성됐음을 확인할 수 있다.
//타입스크립트가 index.ts의 코드를 컴파일해서 낮은버전의 자바스크립트 코드로 바꿔준다.

//TARGET은 어떤버전의 자바스크립트로 타입스크립트를 컴파일하고 싶은지 나타낸다.
//ES3는 CONST가 존재하지 않는다 var만 존재한다. 또한 화살표 함수도 존재하지 않아서 일반적이 함수로 바뀐다.
//때문에 우리는 es6로 설정해 줄 것이다.
//그러고 build를 다시해주면 index.js에서 화살표함수와 const로 컴파일하고 있는 모습을 볼 수 있을 것이다.
//타입스크립트는 호환되는 코드로 컴파일해주는 장점이 있다.

//target을 "es3"로 설정하고, index.ts에 class형으로 써보면
//타입스크립트는 클래스가존재하지 않는 옛날 버전의 자바스크립트로 컴파일 한 모습을 볼 수 있다.

//cra를 쓴다면 라이브러리들이 알아서 target을 생성해줄 것이다. 하지만, 우리는 target이 어떤 역할을 하는지 알고 있어야한다!!
//만약 target을 아무것도 쓰지 않는다면 es3나 es5로 컴파일 될 것이다.

//lib는 합쳐진 라이브러리의 정의 파일을 특정해주는 역할을 한다.
//lib에 마우스 오버해보면 Specify a set of bundled library declaration files that describe the target runtime environment 라고 나오는데
//library declaration은 목표로하는 실행환경을 나타낸다고 적어져있다.
//이 말은 자바스크립트 코드가 어디에서 동작할지를 알려준다. 즉, 자바스크립트의 어던 버전이 그 환경(environment)에서 사용되는지를 알려준다.
//테스트를 위해서 우리의 코드가 es6를 지원하는 환경에서 실행될 것이라고 지정해보자.
//또, 브라우저 위에서 실행한다고 알려주기 위해서 "DOM"을 작성해준다.
//DOM을 lib에 쓴것과 안쓴것의 차이점은 무엇일까? dom을 포함하고 타입스크립트 코드에서 document를 쓰면,
//타입스크립트는 document를 인식하고, document가 가지고 있는 모든 이벤트와 메소드를 보여준다.
//왜냐하면 타입스크립트는 브라우저의 API와 타입들을 알고있기 때문이다.

//lib의 핵심은 이 한줄로 타입스크립트에게 코드가 어디서 동작할 것인지 알려줄 수 있다는 것이다.
//그러면 타입스크립트는 내가 사용할 API가 무엇인지 알기 때문에 자동완성 기능을 제공할 수 있다.
//예를 들어 DOM을 지우면 타입스크립트는 내가 브라우저를 위한 코드를 작성한 다는 것을 모른다.
//DOM을 지운상태에서 index.ts에 가서 document를 작성하면 document가 가지고 있는 속성들은 아무것도 뜨지 않고 존재하지 않는 것으로 나온다.
//결론적으로 lib에 dom이라는 것을 적어줌으로써 다양한 api(=옵션)(이벤트, 메소드 등)을 자동완성해서 사용할 수 있게해준다.
//고로 lib는 타입스크립트에게 어떤 api를 사용하고 어떤 환경에서 코드를 실행하는지 말해준다.
//이것이 바로 타겟 런타임 인바이런먼트다.

//Declaration files는 뭐야?
//lib를 마우스오버해서 링크에 들어가보면 어떤 착한 사람이
//document 오브젝트의 모양과 인자, 리턴타입 같은 모든 것을 설명해주고,
//math나 window 등도 모~두 설명할 수 있도록 만들어 줬다고 써져있다.
//그 문장이 "default set of type definitions"인데, 위의 설명을 한 단어로 축약하면 type definition(타입정의)이다.
//타입 정의는 타입스크립트에게 몇몇 자바스크립트 코드와 API의 타입을 설명해주기위해 사용하는 것이다.
//우리가 타입정의를 사용하는 이유는 우리가 타입스크립트를 사용하는 목적과 연결이 되는데
//타입스크립트는 다양한 타입과 소통이 되어야한다. 하지만 우리는 대부분의 경우 다른 패키지나 프레임워크, 라이브러리를 사용한다.
//패키지나 프레임워크, 라이브러리는 타입스크립트가 아니라 자바스크립트로 만들어졌기 때문에
//우리가 자바스크립트로 만들어진 라이브러리를 타입스크립트 프로젝트에 쓰려고 한다면
//타입스크립트는 그것들의 타입을 알 길이 없다.
//때문에 타입스크립트에게 우리가 불러올 자바스크립트 함수의 모양을 설명하기 위해서 타입 정의가 필요하다.

//하! localstorage.clear를 index.ts에 써보고 컨트롤을 프레스하고 localstorage.clear를 눌러보면
//lib.dom.d.ts라는 파일에 들어가서 localstorage.clear에 대한 내용이 써져있는 것을 확인할 수 있을 것이다.
//이 파일에서 lib.dom.d.ts에서 d가 바로 declaration file이다.

//strict mode
//타입스크립트가 우리를 보호해주지 못하는 경우가 종종있다.
//굉장히 성가시지만 타입스크립트의 확실한 케어를 받고 싶을 때 꼭 strict 모드를 true로 활성화시키자

//allowJs
//자바스크립트 파일로 프로젝트를 진행했는데, 타입스크립트의 보호를 받고싶을 때 활성화 시켜주면 된다.
//해당 자바스크립트 파일에 가서 '//@ts-check' 라고 써주면 타입스크립트가 해당 자바스크립트 파일을 체킹하기 시작한다.
//어떤 방식으로 체킹을 받을건지는 사용자가 직접 설정해줘야하는데, 그 때 사용하는 것이 jsDoc이다.
//jsDoc은 '//@ts-check' 아래에 원하는 부분쪽에 /**를 치면 jsDoc이 자동 완성되어 쓸 수 있도록 해준다.
//jsDoc에 타입스크립트가 체킹해줬으면 하는 대로 입력하면 된다.
//절대 js파일을 다시 타입스크립트로 써줄 필요가 없다. 프로덕션에서 사용중인 웹사이트거나 서버에서 돌아가는 코드인데
//타입스크립트의 보호는 받고싶으데 고장날까봐 걱정이라면 이 방법을 사용하면 된다.

//esModuleInterop
//import 할 때 우리가 import만 쓸 수 있었던 이유,,
//이 것을 활성화시켜주지 않으면 우리는 import * as ~~라고 써줘야만한다.

{
  "include": ["src"],
  "compilerOptions": {
    "outDir": "build",
    "target": "es6",
    "lib": [
      "es6"
      // "DOM"
    ],
    "strict": true,
    // "allowJs": true,
    "esModuleInterop": true,
    "module": "CommonJs"
  }
}
